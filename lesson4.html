<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div id="stats"></div>
    <div id="three"></div>
    <script src="./three.js"></script>
    <script src="./stats.min.js"></script>
    <script>
      //增加统计功能
      //初始化统计对象，这个只是工具，用来检测动画相关数值的
      const initStats = () => {
        const stats = new Stats();
        //设置模式：0--显示fps；1--检测渲染时间
        stats.setMode(0);
        stats.domElement.style.position = "absolute";
        stats.domElement.style.left = 0;
        stats.domElement.style.top = 0;
        document.getElementById("stats").appendChild(stats.domElement);
        return stats;
      };

      const stats = initStats();

      //设置场景
      const scene = new THREE.Scene();

      //设置相机，这里是设置透视相机，参数分别为（视角，宽高比例，近聚点，远聚点）
      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      //设置相机的位置
      camera.position.x = -30;
      camera.position.y = 40;
      camera.position.z = 30;
      //让相机指向场景的中央
      camera.lookAt(scene.position);

      //设置绘制对象，基于webGL的渲染器，还有基于canvas和svg等等
      const renderer = new THREE.WebGLRenderer();
      renderer.setClearColor(new THREE.Color(0xeeeeee));
      renderer.setSize(window.innerWidth, window.innerHeight);
      //添加阴影
      renderer.shadowMapEnabled = true;

      //设置辅助测试工具
      const axes = new THREE.AxesHelper(20);
      //添加测试工具
      scene.add(axes);

      //设置平面
      //设置平面宽高和平面的宽高段数，宽高段数可以使平面更加精细，具体怎么调不清楚
      const planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1);
      //设置平面材质，这里只设置了颜色
      const planeMeterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
      //创建平面
      const plane = new THREE.Mesh(planeGeometry, planeMeterial);

      //设置平面的旋转角度和定位
      plane.rotation.x = -0.5 * Math.PI;
      plane.position.x = 15;
      plane.position.y = 0;
      plane.position.z = 0;
      //打开地面阴影
      plane.receiveShadow = true;
      //添加平面
      scene.add(plane);

      //设置立方体
      //设置平面（宽，高，深度，宽段数，高段数，深度段数）；
      const cubeGeometry = new THREE.CubeGeometry(4, 4, 4);
      //设置立方体材质，这里设置了颜色和显示线框
      const cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
      //创建立方体
      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      //设置立方体的位置
      cube.position.x = 4;
      cube.position.y = 4;
      cube.position.z = 4;
      //打开立方体的阴影
      cube.castShadow = true;
      //添加立方体
      scene.add(cube);

      //设置球面体(radius,widthSegments,heightSegment,phiStart,phiLength,thetaStart,thetaLength)
      //设置了半径和段数
      const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
      //设置球面体材质，这里设置了颜色和显示线框
      const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff });
      //创建球面体
      const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      //设置立方体的位置
      sphere.position.x = 20;
      sphere.position.y = 4;
      sphere.position.z = -2;
      //打开球面体的阴影
      sphere.castShadow = true;
      //添加球面体
      scene.add(sphere);

      //设置光源（这里是点光源，设置的是光的颜色）
      const spotLight = new THREE.SpotLight(0xffffff);
      //设置点光源的位置
      spotLight.position.set(-40, 60, -10);
      //设置光源可以生产阴影
      spotLight.castShadow = true;
      //把点光源增加到场景中
      scene.add(spotLight);

      //引入动画
      let step = 0;
      const render = () => {
        stats.update();
        //旋转立方体的代码
        cube.rotation.x += 0.02;
        cube.rotation.y += 0.02;
        cube.rotation.z += 0.02;

        //跳动球体的代码
        step += 0.04;
        //通过三角函数来实现平滑的的运动轨迹
        sphere.position.x = 20 + (10 * Math.cos(step));
        sphere.position.y = 2 + (10 * Math.abs(Math.sin(step)));

        requestAnimationFrame(render);
        renderer.render(scene, camera);
      };

      //将renderer的输出挂在到元素中
      document.getElementById("three").appendChild(renderer.domElement);

      render();
    </script>
  </body>
</html>
